//// starting scenario
scenario SCENARIO_NAME
load ../KingOfTheEtherThroneAttack.asm
check transaction = false;
check current_layer = 0;
set random_user := attacker;
set random_function := attack;
step
check transaction = true;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check current_layer = 0;
check global_state_layer = 0;
set random_user := attacker;
set random_function := attack;
step
check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 0;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check current_layer = 1;
check global_state_layer = 1;
set random_user := kotET;
set random_function := fallback;
step
check transaction = true;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 0;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check current_layer = 1;
check global_state_layer = 1;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 0;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check current_layer = 2;
check global_state_layer = 2;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 1;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check current_layer = 2;
check global_state_layer = 2;
set random_user := kotET;
set random_function := fallback;
step
check transaction = true;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 1;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check current_layer = 2;
check global_state_layer = 2;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 2;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = initial_king;
check balance(attacker,3) = 10;
check claim_price(3) = 1;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 3;
check global_state_layer = 3;
set random_user := kotET;
set random_function := fallback;
step


check balance(kotET, global_state_layer) = balance(kotET, global_state_layer - 1) - claim_price(global_state_layer);



check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 2;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = initial_king;
check balance(attacker,3) = 10;
check claim_price(3) = 1;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 2;
check global_state_layer = 3;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 3;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 1;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 2;
check global_state_layer = 3;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 4;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 2;
check global_state_layer = 3;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 4;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 1;
check global_state_layer = 3;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = attack;
check balance(kotET,0) = 10;
check balance(initial_king,0) = 10;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 1;
check receiver(1) = attacker;
check balance(user,0) = 10;
check king(0) = initial_king;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 4;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 0;
check global_state_layer = 3;
set random_user := kotET;
set random_function := fallback;
step
check transaction = true;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 10;
check executing_contract(1) = attacker;
check executing_function(1) = attack;
check balance(initial_king,1) = 10;
check instruction_pointer(1) = 1;
check claim_price(1) = 1;
check balance(user,1) = 7;
check king(1) = initial_king;
check balance(attacker,1) = 13;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 4;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 0;
check global_state_layer = 0;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 15;
check executing_contract(1) = kotET;
check executing_function(1) = fallback;
check balance(initial_king,1) = 11;
check instruction_pointer(1) = 0;
check claim_price(1) = 2;
check balance(user,1) = 4;
check king(1) = attacker;
check balance(attacker,1) = 10;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 4;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 1;
check global_state_layer = 1;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 15;
check executing_contract(1) = kotET;
check executing_function(1) = fallback;
check balance(initial_king,1) = 11;
check instruction_pointer(1) = 1;
check claim_price(1) = 2;
check balance(user,1) = 4;
check king(1) = attacker;
check balance(attacker,1) = 10;
check function_call(2) = fallback;
check amount(2) = 3;
check sender(2) = attacker;
check receiver(2) = kotET;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 4;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 1;
check global_state_layer = 1;
set random_user := kotET;
set random_function := fallback;
step
check transaction = true;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 15;
check executing_contract(1) = kotET;
check executing_function(1) = fallback;
check balance(initial_king,1) = 11;
check instruction_pointer(1) = 1;
check claim_price(1) = 2;
check balance(user,1) = 4;
check king(1) = attacker;
check balance(attacker,1) = 10;
check function_call(2) = fallback;
check amount(2) = 2;
check sender(2) = kotET;
check receiver(2) = attacker;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 10;
check claim_price(2) = 1;
check king(2) = initial_king;
check balance(attacker,2) = 10;
check executing_contract(2) = kotET;
check instruction_pointer(2) = 4;
check executing_function(2) = fallback;
check balance(user,2) = 7;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 1;
check global_state_layer = 1;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 15;
check executing_contract(1) = kotET;
check executing_function(1) = fallback;
check balance(initial_king,1) = 11;
check instruction_pointer(1) = 2;
check claim_price(1) = 2;
check balance(user,1) = 4;
check king(1) = attacker;
check balance(attacker,1) = 10;
check function_call(2) = fallback;
check amount(2) = 2;
check sender(2) = kotET;
check receiver(2) = attacker;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 11;
check claim_price(2) = 2;
check king(2) = attacker;
check balance(attacker,2) = 12;
check executing_contract(2) = attacker;
check instruction_pointer(2) = 0;
check executing_function(2) = fallback;
check balance(user,2) = 4;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 2;
check global_state_layer = 2;
set random_user := kotET;
set random_function := fallback;
step


check balance(kotET, global_state_layer) = balance(kotET, global_state_layer - 1) - claim_price(global_state_layer);


check transaction = false;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 15;
check executing_contract(1) = kotET;
check executing_function(1) = fallback;
check balance(initial_king,1) = 11;
check instruction_pointer(1) = 2;
check claim_price(1) = 2;
check balance(user,1) = 4;
check king(1) = attacker;
check balance(attacker,1) = 10;
check function_call(2) = fallback;
check amount(2) = 2;
check sender(2) = kotET;
check receiver(2) = attacker;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 11;
check claim_price(2) = 2;
check king(2) = attacker;
check balance(attacker,2) = 12;
check executing_contract(2) = attacker;
check instruction_pointer(2) = 0;
check executing_function(2) = fallback;
check balance(user,2) = 4;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 1;
check global_state_layer = 1;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 15;
check executing_contract(1) = kotET;
check executing_function(1) = fallback;
check balance(initial_king,1) = 11;
check instruction_pointer(1) = 3;
check claim_price(1) = 2;
check balance(user,1) = 4;
check king(1) = user;
check balance(attacker,1) = 10;
check function_call(2) = fallback;
check amount(2) = 2;
check sender(2) = kotET;
check receiver(2) = attacker;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 11;
check claim_price(2) = 2;
check king(2) = attacker;
check balance(attacker,2) = 12;
check executing_contract(2) = attacker;
check instruction_pointer(2) = 0;
check executing_function(2) = fallback;
check balance(user,2) = 4;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 1;
check global_state_layer = 1;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 15;
check executing_contract(1) = kotET;
check executing_function(1) = fallback;
check balance(initial_king,1) = 11;
check instruction_pointer(1) = 4;
check claim_price(1) = 3;
check balance(user,1) = 4;
check king(1) = user;
check balance(attacker,1) = 10;
check function_call(2) = fallback;
check amount(2) = 2;
check sender(2) = kotET;
check receiver(2) = attacker;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 11;
check claim_price(2) = 2;
check king(2) = attacker;
check balance(attacker,2) = 12;
check executing_contract(2) = attacker;
check instruction_pointer(2) = 0;
check executing_function(2) = fallback;
check balance(user,2) = 4;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 1;
check global_state_layer = 1;
set random_user := kotET;
set random_function := fallback;
step
check transaction = false;
check function_call(1) = fallback;
check balance(kotET,0) = 12;
check balance(initial_king,0) = 11;
check amount(1) = 3;
check sender(1) = user;
check claim_price(0) = 2;
check receiver(1) = kotET;
check balance(user,0) = 7;
check king(0) = attacker;
check balance(attacker,0) = 10;
check balance(kotET,1) = 15;
check executing_contract(1) = kotET;
check executing_function(1) = fallback;
check balance(initial_king,1) = 11;
check instruction_pointer(1) = 4;
check claim_price(1) = 3;
check balance(user,1) = 4;
check king(1) = user;
check balance(attacker,1) = 10;
check function_call(2) = fallback;
check amount(2) = 2;
check sender(2) = kotET;
check receiver(2) = attacker;
check balance(kotET,2) = 13;
check balance(initial_king,2) = 11;
check claim_price(2) = 2;
check king(2) = attacker;
check balance(attacker,2) = 12;
check executing_contract(2) = attacker;
check instruction_pointer(2) = 0;
check executing_function(2) = fallback;
check balance(user,2) = 4;
check function_call(3) = fallback;
check amount(3) = 1;
check sender(3) = kotET;
check receiver(3) = initial_king;
check balance(kotET,3) = 12;
check balance(initial_king,3) = 11;
check king(3) = attacker;
check balance(attacker,3) = 10;
check claim_price(3) = 2;
check executing_contract(3) = initial_king;
check executing_function(3) = fallback;
check instruction_pointer(3) = 0;
check balance(user,3) = 7;
check current_layer = 0;
check global_state_layer = 1;
step



